//------------------------------------------------------------------------------
// <auto-generated>                                                             
//     This code was generated by a tool.                                       
//     Changes to this file may cause incorrect behavior and will be lost if    
//     the code is regenerated.                                                 
// </auto-generated>                                                            
//------------------------------------------------------------------------------
#pragma warning disable 436
#pragma warning disable 162
#pragma warning disable 1591
using System;
using Microsoft.Quantum.Core;
using Microsoft.Quantum.Intrinsic;
using Microsoft.Quantum.Simulation.Core;

[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"Quantum.Bell\",\"Name\":\"FactorSemiprimeInteger\"},\"Attributes\":[],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs\",\"Position\":{\"Item1\":34,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":33}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"number\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":34},\"Item2\":{\"Line\":1,\"Column\":40}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"useRobustPhaseEstimation\"]},\"Type\":{\"Case\":\"Bool\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":48},\"Item2\":{\"Line\":1,\"Column\":72}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"Bool\"}]]},\"ReturnType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"Int\"}]]},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" Uses Shor's algorithm to factor the parameter `number`\",\"\",\" # Input\",\" ## number\",\" A semiprime integer to be factored\",\" ## useRobustPhaseEstimation\",\" If set to true, we use Microsoft.Quantum.Characterization.RobustPhaseEstimation and\",\" Microsoft.Quantum.Characterization.QuantumPhaseEstimation otherwise\",\"\",\" # Output\",\" Pair of numbers p > 1 and q > 1 such that p⋅q = `number`\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"Quantum.Bell\",\"Name\":\"FactorSemiprimeInteger\"},\"Attributes\":[],\"SourceFile\":\"/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs\",\"Position\":{\"Item1\":34,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":33}},\"Documentation\":[]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"Quantum.Bell\",\"Name\":\"ApplyOrderFindingOracle\"},\"Attributes\":[],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs\",\"Position\":{\"Item1\":112,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":34}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"generator\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":2,\"Column\":9},\"Item2\":{\"Line\":2,\"Column\":18}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"modulus\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":2,\"Column\":26},\"Item2\":{\"Line\":2,\"Column\":33}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"power\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":2,\"Column\":41},\"Item2\":{\"Line\":2,\"Column\":46}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"target\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":2,\"Column\":54},\"Item2\":{\"Line\":2,\"Column\":60}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"Int\"},{\"Case\":\"Int\"},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]}]]},\"ReturnType\":{\"Case\":\"UnitType\"},\"Information\":{\"Characteristics\":{\"Case\":\"Union\",\"Fields\":[{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Adjointable\"}]},{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Controllable\"}]}]},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" Interprets `target` as encoding unsigned little-endian integer k\",\" and performs transformation |k⟩ ↦ |gᵖ⋅k mod N ⟩ where\",\" p is `power`, g is `generator` and N is `modulus`.\",\"\",\" # Input\",\" ## generator\",\" The unsigned integer multiplicative order ( period )\",\" of which is being estimated. Must be co-prime to `modulus`.\",\" ## modulus\",\" The modulus which defines the residue ring Z mod `modulus`\",\" in which the multiplicative order of `generator` is being estimated.\",\" ## power\",\" Power of `generator` by which `target` is multiplied.\",\" ## target\",\" Register interpreted as LittleEndian which is multiplied by\",\" given power of the generator. The multiplication is performed modulo\",\" `modulus`.\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"Union\",\"Fields\":[{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Adjointable\"}]},{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Controllable\"}]}]},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"Quantum.Bell\",\"Name\":\"ApplyOrderFindingOracle\"},\"Attributes\":[],\"SourceFile\":\"/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs\",\"Position\":{\"Item1\":112,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":34}},\"Documentation\":[]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsAdjoint\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"Union\",\"Fields\":[{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Adjointable\"}]},{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Controllable\"}]}]},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"Quantum.Bell\",\"Name\":\"ApplyOrderFindingOracle\"},\"Attributes\":[],\"SourceFile\":\"/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs\",\"Position\":{\"Item1\":112,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":5,\"Column\":8},\"Item2\":{\"Line\":5,\"Column\":17}},\"Documentation\":[\"automatically generated QsAdjoint specialization for Quantum.Bell.ApplyOrderFindingOracle\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsControlled\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"Union\",\"Fields\":[{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Adjointable\"}]},{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Controllable\"}]}]},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"Quantum.Bell\",\"Name\":\"ApplyOrderFindingOracle\"},\"Attributes\":[],\"SourceFile\":\"/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs\",\"Position\":{\"Item1\":112,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":5,\"Column\":8},\"Item2\":{\"Line\":5,\"Column\":17}},\"Documentation\":[\"automatically generated QsControlled specialization for Quantum.Bell.ApplyOrderFindingOracle\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsControlledAdjoint\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"Union\",\"Fields\":[{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Adjointable\"}]},{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Controllable\"}]}]},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"Quantum.Bell\",\"Name\":\"ApplyOrderFindingOracle\"},\"Attributes\":[],\"SourceFile\":\"/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs\",\"Position\":{\"Item1\":112,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":5,\"Column\":8},\"Item2\":{\"Line\":5,\"Column\":17}},\"Documentation\":[\"automatically generated QsControlledAdjoint specialization for Quantum.Bell.ApplyOrderFindingOracle\"]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"Quantum.Bell\",\"Name\":\"EstimatePeriod\"},\"Attributes\":[],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs\",\"Position\":{\"Item1\":148,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":25}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"generator\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":2,\"Column\":9},\"Item2\":{\"Line\":2,\"Column\":18}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"modulus\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":2,\"Column\":26},\"Item2\":{\"Line\":2,\"Column\":33}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"useRobustPhaseEstimation\"]},\"Type\":{\"Case\":\"Bool\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":2,\"Column\":41},\"Item2\":{\"Line\":2,\"Column\":65}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"Int\"},{\"Case\":\"Bool\"}]]},\"ReturnType\":{\"Case\":\"Int\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" Finds a multiplicative order of the generator\",\" in the residue ring Z mod `modulus`.\",\"\",\" # Input\",\" ## generator\",\" The unsigned integer multiplicative order ( period )\",\" of which is being estimated. Must be co-prime to `modulus`.\",\" ## modulus\",\" The modulus which defines the residue ring Z mod `modulus`\",\" in which the multiplicative order of `generator` is being estimated.\",\" ## useRobustPhaseEstimation\",\" If set to true, we use Microsoft.Quantum.Characterization.RobustPhaseEstimation and\",\" Microsoft.Quantum.Characterization.QuantumPhaseEstimation\",\"\",\" # Output\",\" The period ( multiplicative order ) of the generator mod `modulus`\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"Quantum.Bell\",\"Name\":\"EstimatePeriod\"},\"Attributes\":[],\"SourceFile\":\"/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs\",\"Position\":{\"Item1\":148,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":25}},\"Documentation\":[]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"Quantum.Bell\",\"Name\":\"EstimateFrequency\"},\"Attributes\":[],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs\",\"Position\":{\"Item1\":216,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":28}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"generator\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":2,\"Column\":9},\"Item2\":{\"Line\":2,\"Column\":18}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"modulus\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":3,\"Column\":9},\"Item2\":{\"Line\":3,\"Column\":16}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"useRobustPhaseEstimation\"]},\"Type\":{\"Case\":\"Bool\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":4,\"Column\":9},\"Item2\":{\"Line\":4,\"Column\":33}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"bitsize\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":5,\"Column\":9},\"Item2\":{\"Line\":5,\"Column\":16}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"Int\"},{\"Case\":\"Bool\"},{\"Case\":\"Int\"}]]},\"ReturnType\":{\"Case\":\"Int\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" Estimates the frequency of a generator\",\" in the residue ring Z mod `modulus`.\",\"\",\" # Input\",\" ## generator\",\" The unsigned integer multiplicative order ( period )\",\" of which is being estimated. Must be co-prime to `modulus`.\",\" ## modulus\",\" The modulus which defines the residue ring Z mod `modulus`\",\" in which the multiplicative order of `generator` is being estimated.\",\" ## useRobustPhaseEstimation\",\" If set to true, we use Microsoft.Quantum.Characterization.RobustPhaseEstimation else\",\" this operation uses Microsoft.Quantum.Characterization.QuantumPhaseEstimation\",\" ## bitsize\",\" Number of bits needed to represent the modulus.\",\"\",\" # Output\",\" The numerator k of dyadic fraction k/2^bitsPrecision\",\" approximating s/r.\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"Quantum.Bell\",\"Name\":\"EstimateFrequency\"},\"Attributes\":[],\"SourceFile\":\"/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs\",\"Position\":{\"Item1\":216,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":28}},\"Documentation\":[]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Function\"},\"QualifiedName\":{\"Namespace\":\"Quantum.Bell\",\"Name\":\"PeriodFromFrequency\"},\"Attributes\":[],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs\",\"Position\":{\"Item1\":305,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":10},\"Item2\":{\"Line\":1,\"Column\":29}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"modulus\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":2,\"Column\":9},\"Item2\":{\"Line\":2,\"Column\":16}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"frequencyEstimate\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":3,\"Column\":9},\"Item2\":{\"Line\":3,\"Column\":26}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"bitsPrecision\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":4,\"Column\":9},\"Item2\":{\"Line\":4,\"Column\":22}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"currentDivisor\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":5,\"Column\":9},\"Item2\":{\"Line\":5,\"Column\":23}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"Int\"},{\"Case\":\"Int\"},{\"Case\":\"Int\"}]]},\"ReturnType\":{\"Case\":\"Int\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" Find the period of a number from an input frequency.\",\"\",\" # Input\",\" ## modulus\",\" The modulus which defines the residue ring Z mod `modulus`\",\" in which the multiplicative order of `generator` is being estimated.\",\" ## frequencyEstimate\",\" The frequency that we want to convert to a period.\",\" ## bitsPrecision\",\" Number of bits of precision with which we need to\",\" estimate s/r to recover period r using continued\",\" fractions algorithm.\",\" ## currentDivisor\",\" The divisor of the generator period found so far.\",\"\",\" # Output\",\" The period as calculated from the estimated frequency via\",\" the continued fractions algorithm.\",\"\",\" # See Also\",\" - Microsoft.Quantum.Math.ContinuedFractionConvergentI\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"Quantum.Bell\",\"Name\":\"PeriodFromFrequency\"},\"Attributes\":[],\"SourceFile\":\"/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs\",\"Position\":{\"Item1\":305,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":10},\"Item2\":{\"Line\":1,\"Column\":29}},\"Documentation\":[]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Function\"},\"QualifiedName\":{\"Namespace\":\"Quantum.Bell\",\"Name\":\"MaybeFactorsFromPeriod\"},\"Attributes\":[],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs\",\"Position\":{\"Item1\":348,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":10},\"Item2\":{\"Line\":1,\"Column\":32}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"modulus\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":33},\"Item2\":{\"Line\":1,\"Column\":40}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"generator\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":48},\"Item2\":{\"Line\":1,\"Column\":57}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"period\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":65},\"Item2\":{\"Line\":1,\"Column\":71}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"Int\"},{\"Case\":\"Int\"}]]},\"ReturnType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Bool\"},{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"Int\"}]]}]]},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" Tries to find the factors of `modulus` given a `period` and `generator`.\",\"\",\" # Input\",\" ## modulus\",\" The modulus which defines the residue ring Z mod `modulus`\",\" in which the multiplicative order of `generator` is being estimated.\",\" ## generator\",\" The unsigned integer multiplicative order ( period )\",\" of which is being estimated. Must be co-prime to `modulus`.\",\" ## period\",\" The estimated period ( multiplicative order ) of the generator mod `modulus`.\",\"\",\" # Output\",\" A tuple of a flag indicating whether factors were found successfully,\",\" and a pair of integers representing the factors that were found.\",\" Note that the second output is only meaningful when the first\",\" output is `true`.\",\"\",\" # See Also\",\" - Microsoft.Quantum.Math.GreatestCommonDivisorI\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"Quantum.Bell\",\"Name\":\"MaybeFactorsFromPeriod\"},\"Attributes\":[],\"SourceFile\":\"/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs\",\"Position\":{\"Item1\":348,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":10},\"Item2\":{\"Line\":1,\"Column\":32}},\"Documentation\":[]}")]
#line hidden
namespace Quantum.Bell
{
    [SourceLocation("/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs", OperationFunctor.Body, 35, 113)]
    public partial class FactorSemiprimeInteger : Operation<(Int64,Boolean), (Int64,Int64)>, ICallable
    {
        public FactorSemiprimeInteger(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(Int64,Boolean)>, IApplyData
        {
            public In((Int64,Boolean) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits => null;
        }

        public class Out : QTuple<(Int64,Int64)>, IApplyData
        {
            public Out((Int64,Int64) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits => null;
        }

        String ICallable.Name => "FactorSemiprimeInteger";
        String ICallable.FullName => "Quantum.Bell.FactorSemiprimeInteger";
        protected ICallable<String, QVoid> Message
        {
            get;
            set;
        }

        protected ICallable<Int64, Int64> MicrosoftQuantumMathRandomInt
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64), Boolean> MicrosoftQuantumMathIsCoprimeI
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64,Boolean), Int64> EstimatePeriod
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64,Int64), (Boolean,(Int64,Int64))> MaybeFactorsFromPeriod
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64), Int64> MicrosoftQuantumMathGreatestCommonDivisorI
        {
            get;
            set;
        }

        public override Func<(Int64,Boolean), (Int64,Int64)> Body => (__in__) =>
        {
            var (number,useRobustPhaseEstimation) = __in__;
#line 38 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            if (((number % 2L) == 0L))
            {
#line 39 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                Message.Apply("An even number has been given; 2 is a factor.");
#line 40 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                return ((number / 2L), 2L);
            }

#line 45 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            var foundFactors = false;
#line 46 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            var factors = (1L, 1L);
#line 48 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            while (true)
            {
#line 51 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                var generator = (MicrosoftQuantumMathRandomInt.Apply((number - 2L)) + 1L);
#line 56 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                if (MicrosoftQuantumMathIsCoprimeI.Apply((generator, number)))
                {
#line 60 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                    Message.Apply(String.Format("Estimating period of {0}", generator));
#line 65 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                    var period = EstimatePeriod.Apply((generator, number, useRobustPhaseEstimation));
#line 69 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                    (foundFactors, factors) = MaybeFactorsFromPeriod.Apply((number, generator, period));
                }
                else
                {
#line 74 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                    var gcd = MicrosoftQuantumMathGreatestCommonDivisorI.Apply((number, generator));
#line 78 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                    Message.Apply(String.Format("We have guessed a divisor of {0} to be {1} by accident.", number, gcd));
#line 82 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                    foundFactors = true;
#line 83 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                    factors = (gcd, (number / gcd));
                }

                if (foundFactors)
                {
                    break;
                }
                else
                {
#line 88 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                    Message.Apply("The estimated period did not yield a valid factor, trying again.");
                }
            }

#line 92 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            return factors;
        }

        ;
        public override void Init()
        {
            this.Message = this.Factory.Get<ICallable<String, QVoid>>(typeof(Microsoft.Quantum.Intrinsic.Message));
            this.MicrosoftQuantumMathRandomInt = this.Factory.Get<ICallable<Int64, Int64>>(typeof(Microsoft.Quantum.Math.RandomInt));
            this.MicrosoftQuantumMathIsCoprimeI = this.Factory.Get<ICallable<(Int64,Int64), Boolean>>(typeof(Microsoft.Quantum.Math.IsCoprimeI));
            this.EstimatePeriod = this.Factory.Get<ICallable<(Int64,Int64,Boolean), Int64>>(typeof(EstimatePeriod));
            this.MaybeFactorsFromPeriod = this.Factory.Get<ICallable<(Int64,Int64,Int64), (Boolean,(Int64,Int64))>>(typeof(MaybeFactorsFromPeriod));
            this.MicrosoftQuantumMathGreatestCommonDivisorI = this.Factory.Get<ICallable<(Int64,Int64), Int64>>(typeof(Microsoft.Quantum.Math.GreatestCommonDivisorI));
        }

        public override IApplyData __dataIn((Int64,Boolean) data) => new In(data);
        public override IApplyData __dataOut((Int64,Int64) data) => new Out(data);
        public static System.Threading.Tasks.Task<(Int64,Int64)> Run(IOperationFactory __m__, Int64 number, Boolean useRobustPhaseEstimation)
        {
            return __m__.Run<FactorSemiprimeInteger, (Int64,Boolean), (Int64,Int64)>((number, useRobustPhaseEstimation));
        }
    }

    [SourceLocation("/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs", OperationFunctor.Body, 113, 149)]
    [SourceLocation("/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs", OperationFunctor.Adjoint, 113, 149)]
    [SourceLocation("/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs", OperationFunctor.Controlled, 113, 149)]
    [SourceLocation("/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs", OperationFunctor.ControlledAdjoint, 113, 149)]
    public partial class ApplyOrderFindingOracle : Unitary<(Int64,Int64,Int64,IQArray<Qubit>)>, ICallable
    {
        public ApplyOrderFindingOracle(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(Int64,Int64,Int64,IQArray<Qubit>)>, IApplyData
        {
            public In((Int64,Int64,Int64,IQArray<Qubit>) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits
            {
                get
                {
                    return ((IApplyData)Data.Item4)?.Qubits;
                }
            }
        }

        String ICallable.Name => "ApplyOrderFindingOracle";
        String ICallable.FullName => "Quantum.Bell.ApplyOrderFindingOracle";
        protected ICallable<(Boolean,String), QVoid> MicrosoftQuantumDiagnosticsFact
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64), Boolean> MicrosoftQuantumMathIsCoprimeI
        {
            get;
            set;
        }

        protected IUnitary<(Int64,Int64,Microsoft.Quantum.Arithmetic.LittleEndian)> MicrosoftQuantumArithmeticMultiplyByModularInteger
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64,Int64), Int64> MicrosoftQuantumMathExpModI
        {
            get;
            set;
        }

        protected ICallable<IQArray<Qubit>, Microsoft.Quantum.Arithmetic.LittleEndian> MicrosoftQuantumArithmeticLittleEndian
        {
            get;
            set;
        }

        public override Func<(Int64,Int64,Int64,IQArray<Qubit>), QVoid> Body => (__in__) =>
        {
            var (generator,modulus,power,target) = __in__;
#line 119 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            MicrosoftQuantumDiagnosticsFact.Apply((MicrosoftQuantumMathIsCoprimeI.Apply((generator, modulus)), "`generator` and `modulus` must be co-prime"));
#line 129 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            MicrosoftQuantumArithmeticMultiplyByModularInteger.Apply((MicrosoftQuantumMathExpModI.Apply((generator, power, modulus)), modulus, new Microsoft.Quantum.Arithmetic.LittleEndian(target)));
#line hidden
            return QVoid.Instance;
        }

        ;
        public override Func<(Int64,Int64,Int64,IQArray<Qubit>), QVoid> AdjointBody => (__in__) =>
        {
            var (generator,modulus,power,target) = __in__;
#line 113 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            MicrosoftQuantumDiagnosticsFact.Apply((MicrosoftQuantumMathIsCoprimeI.Apply((generator, modulus)), "`generator` and `modulus` must be co-prime"));
#line 113 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            MicrosoftQuantumArithmeticMultiplyByModularInteger.Adjoint.Apply((MicrosoftQuantumMathExpModI.Apply((generator, power, modulus)), modulus, new Microsoft.Quantum.Arithmetic.LittleEndian(target)));
#line hidden
            return QVoid.Instance;
        }

        ;
        public override Func<(IQArray<Qubit>,(Int64,Int64,Int64,IQArray<Qubit>)), QVoid> ControlledBody => (__in__) =>
        {
            var (__controlQubits__,(generator,modulus,power,target)) = __in__;
#line 113 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            MicrosoftQuantumDiagnosticsFact.Apply((MicrosoftQuantumMathIsCoprimeI.Apply((generator, modulus)), "`generator` and `modulus` must be co-prime"));
#line 113 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            MicrosoftQuantumArithmeticMultiplyByModularInteger.Controlled.Apply((__controlQubits__, (MicrosoftQuantumMathExpModI.Apply((generator, power, modulus)), modulus, new Microsoft.Quantum.Arithmetic.LittleEndian(target))));
#line hidden
            return QVoid.Instance;
        }

        ;
        public override Func<(IQArray<Qubit>,(Int64,Int64,Int64,IQArray<Qubit>)), QVoid> ControlledAdjointBody => (__in__) =>
        {
            var (__controlQubits__,(generator,modulus,power,target)) = __in__;
#line 113 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            MicrosoftQuantumDiagnosticsFact.Apply((MicrosoftQuantumMathIsCoprimeI.Apply((generator, modulus)), "`generator` and `modulus` must be co-prime"));
#line 113 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            MicrosoftQuantumArithmeticMultiplyByModularInteger.Adjoint.Controlled.Apply((__controlQubits__, (MicrosoftQuantumMathExpModI.Apply((generator, power, modulus)), modulus, new Microsoft.Quantum.Arithmetic.LittleEndian(target))));
#line hidden
            return QVoid.Instance;
        }

        ;
        public override void Init()
        {
            this.MicrosoftQuantumDiagnosticsFact = this.Factory.Get<ICallable<(Boolean,String), QVoid>>(typeof(Microsoft.Quantum.Diagnostics.Fact));
            this.MicrosoftQuantumMathIsCoprimeI = this.Factory.Get<ICallable<(Int64,Int64), Boolean>>(typeof(Microsoft.Quantum.Math.IsCoprimeI));
            this.MicrosoftQuantumArithmeticMultiplyByModularInteger = this.Factory.Get<IUnitary<(Int64,Int64,Microsoft.Quantum.Arithmetic.LittleEndian)>>(typeof(Microsoft.Quantum.Arithmetic.MultiplyByModularInteger));
            this.MicrosoftQuantumMathExpModI = this.Factory.Get<ICallable<(Int64,Int64,Int64), Int64>>(typeof(Microsoft.Quantum.Math.ExpModI));
            this.MicrosoftQuantumArithmeticLittleEndian = this.Factory.Get<ICallable<IQArray<Qubit>, Microsoft.Quantum.Arithmetic.LittleEndian>>(typeof(Microsoft.Quantum.Arithmetic.LittleEndian));
        }

        public override IApplyData __dataIn((Int64,Int64,Int64,IQArray<Qubit>) data) => new In(data);
        public override IApplyData __dataOut(QVoid data) => data;
        public static System.Threading.Tasks.Task<QVoid> Run(IOperationFactory __m__, Int64 generator, Int64 modulus, Int64 power, IQArray<Qubit> target)
        {
            return __m__.Run<ApplyOrderFindingOracle, (Int64,Int64,Int64,IQArray<Qubit>), QVoid>((generator, modulus, power, target));
        }
    }

    [SourceLocation("/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs", OperationFunctor.Body, 149, 217)]
    public partial class EstimatePeriod : Operation<(Int64,Int64,Boolean), Int64>, ICallable
    {
        public EstimatePeriod(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(Int64,Int64,Boolean)>, IApplyData
        {
            public In((Int64,Int64,Boolean) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits => null;
        }

        String ICallable.Name => "EstimatePeriod";
        String ICallable.FullName => "Quantum.Bell.EstimatePeriod";
        protected ICallable<(Boolean,String), QVoid> MicrosoftQuantumDiagnosticsFact
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64), Boolean> MicrosoftQuantumMathIsCoprimeI
        {
            get;
            set;
        }

        protected ICallable<Int64, Int64> MicrosoftQuantumMathBitSizeI
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64,Boolean,Int64), Int64> EstimateFrequency
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64,Int64,Int64), Int64> PeriodFromFrequency
        {
            get;
            set;
        }

        protected ICallable<String, QVoid> Message
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64,Int64), Int64> MicrosoftQuantumMathExpModI
        {
            get;
            set;
        }

        public override Func<(Int64,Int64,Boolean), Int64> Body => (__in__) =>
        {
            var (generator,modulus,useRobustPhaseEstimation) = __in__;
#line 154 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            MicrosoftQuantumDiagnosticsFact.Apply((MicrosoftQuantumMathIsCoprimeI.Apply((generator, modulus)), "`generator` and `modulus` must be co-prime"));
#line 157 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            var result = 1L;
#line 160 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            var bitsize = MicrosoftQuantumMathBitSizeI.Apply(modulus);
#line 170 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            var bitsPrecision = ((2L * bitsize) + 1L);
#line 174 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            var frequencyEstimate = 0L;
#line 176 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            while (true)
            {
#line 178 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                frequencyEstimate = EstimateFrequency.Apply((generator, modulus, useRobustPhaseEstimation, bitsize));
#line 182 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                if ((frequencyEstimate != 0L))
                {
#line 183 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                    result = PeriodFromFrequency.Apply((modulus, frequencyEstimate, bitsPrecision, result));
                }
                else
                {
#line 186 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                    Message.Apply("The estimated frequency was 0, trying again.");
                }

                if ((MicrosoftQuantumMathExpModI.Apply((generator, result, modulus)) == 1L))
                {
                    break;
                }
                else
                {
#line 191 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                    Message.Apply("The estimated period from continued fractions failed, trying again.");
                }
            }

#line 194 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            return result;
        }

        ;
        public override void Init()
        {
            this.MicrosoftQuantumDiagnosticsFact = this.Factory.Get<ICallable<(Boolean,String), QVoid>>(typeof(Microsoft.Quantum.Diagnostics.Fact));
            this.MicrosoftQuantumMathIsCoprimeI = this.Factory.Get<ICallable<(Int64,Int64), Boolean>>(typeof(Microsoft.Quantum.Math.IsCoprimeI));
            this.MicrosoftQuantumMathBitSizeI = this.Factory.Get<ICallable<Int64, Int64>>(typeof(Microsoft.Quantum.Math.BitSizeI));
            this.EstimateFrequency = this.Factory.Get<ICallable<(Int64,Int64,Boolean,Int64), Int64>>(typeof(EstimateFrequency));
            this.PeriodFromFrequency = this.Factory.Get<ICallable<(Int64,Int64,Int64,Int64), Int64>>(typeof(PeriodFromFrequency));
            this.Message = this.Factory.Get<ICallable<String, QVoid>>(typeof(Microsoft.Quantum.Intrinsic.Message));
            this.MicrosoftQuantumMathExpModI = this.Factory.Get<ICallable<(Int64,Int64,Int64), Int64>>(typeof(Microsoft.Quantum.Math.ExpModI));
        }

        public override IApplyData __dataIn((Int64,Int64,Boolean) data) => new In(data);
        public override IApplyData __dataOut(Int64 data) => new QTuple<Int64>(data);
        public static System.Threading.Tasks.Task<Int64> Run(IOperationFactory __m__, Int64 generator, Int64 modulus, Boolean useRobustPhaseEstimation)
        {
            return __m__.Run<EstimatePeriod, (Int64,Int64,Boolean), Int64>((generator, modulus, useRobustPhaseEstimation));
        }
    }

    [SourceLocation("/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs", OperationFunctor.Body, 217, 306)]
    public partial class EstimateFrequency : Operation<(Int64,Int64,Boolean,Int64), Int64>, ICallable
    {
        public EstimateFrequency(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(Int64,Int64,Boolean,Int64)>, IApplyData
        {
            public In((Int64,Int64,Boolean,Int64) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits => null;
        }

        String ICallable.Name => "EstimateFrequency";
        String ICallable.FullName => "Quantum.Bell.EstimateFrequency";
        protected Allocate Allocate
        {
            get;
            set;
        }

        protected Release Release
        {
            get;
            set;
        }

        protected ICallable<IQArray<Qubit>, Microsoft.Quantum.Arithmetic.LittleEndian> MicrosoftQuantumArithmeticLittleEndian
        {
            get;
            set;
        }

        protected IUnitary<(Int64,Microsoft.Quantum.Arithmetic.LittleEndian)> MicrosoftQuantumArithmeticApplyXorInPlace
        {
            get;
            set;
        }

        protected ICallable<IUnitary, Microsoft.Quantum.Oracles.DiscreteOracle> MicrosoftQuantumOraclesDiscreteOracle
        {
            get;
            set;
        }

        protected IUnitary<(Int64,Int64,Int64,IQArray<Qubit>)> ApplyOrderFindingOracle
        {
            get;
            set;
        }

        protected ICallable<(Int64,Microsoft.Quantum.Oracles.DiscreteOracle,IQArray<Qubit>), Double> MicrosoftQuantumCharacterizationRobustPhaseEstimation
        {
            get;
            set;
        }

        protected ICallable<Double, Int64> MicrosoftQuantumMathRound
        {
            get;
            set;
        }

        protected ICallable<Int64, Double> MicrosoftQuantumConvertIntAsDouble
        {
            get;
            set;
        }

        protected ICallable<QVoid, Double> MicrosoftQuantumMathPI
        {
            get;
            set;
        }

        protected IUnitary<(Microsoft.Quantum.Oracles.DiscreteOracle,IQArray<Qubit>,Microsoft.Quantum.Arithmetic.BigEndian)> MicrosoftQuantumCharacterizationQuantumPhaseEstimation
        {
            get;
            set;
        }

        protected ICallable<Microsoft.Quantum.Arithmetic.LittleEndian, Microsoft.Quantum.Arithmetic.BigEndian> MicrosoftQuantumArithmeticLittleEndianAsBigEndian
        {
            get;
            set;
        }

        protected ICallable<Microsoft.Quantum.Arithmetic.LittleEndian, Int64> MicrosoftQuantumArithmeticMeasureInteger
        {
            get;
            set;
        }

        protected ICallable<IQArray<Qubit>, QVoid> ResetAll
        {
            get;
            set;
        }

        public override Func<(Int64,Int64,Boolean,Int64), Int64> Body => (__in__) =>
        {
            var (generator,modulus,useRobustPhaseEstimation,bitsize) = __in__;
#line 224 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            var frequencyEstimate = 0L;
#line 225 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            var bitsPrecision = ((2L * bitsize) + 1L);
#line hidden
            {
#line 229 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                var eigenstateRegister = Allocate.Apply(bitsize);
#line hidden
                bool __arg1__ = true;
                try
                {
#line 235 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                    var eigenstateRegisterLE = new Microsoft.Quantum.Arithmetic.LittleEndian(eigenstateRegister);
#line 236 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                    MicrosoftQuantumArithmeticApplyXorInPlace.Apply((1L, eigenstateRegisterLE));
#line 240 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                    var oracle = new Microsoft.Quantum.Oracles.DiscreteOracle(ApplyOrderFindingOracle.Partial(new Func<(Int64,IQArray<Qubit>), (Int64,Int64,Int64,IQArray<Qubit>)>((__arg2__) => (generator, modulus, __arg2__.Item1, __arg2__.Item2))));
#line 242 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                    if (useRobustPhaseEstimation)
                    {
#line 247 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                        var phase = MicrosoftQuantumCharacterizationRobustPhaseEstimation.Apply((bitsPrecision, oracle, eigenstateRegisterLE.Data));
#line 252 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                        frequencyEstimate = MicrosoftQuantumMathRound.Apply((((phase * MicrosoftQuantumConvertIntAsDouble.Apply(2L.Pow(bitsPrecision))) / 2D) / MicrosoftQuantumMathPI.Apply(QVoid.Instance)));
                    }
                    else
                    {
#line hidden
                        {
#line 258 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                            var register = Allocate.Apply(bitsPrecision);
#line hidden
                            bool __arg3__ = true;
                            try
                            {
#line 259 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                                var frequencyEstimateNumerator = new Microsoft.Quantum.Arithmetic.LittleEndian(register);
#line 265 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                                MicrosoftQuantumCharacterizationQuantumPhaseEstimation.Apply((oracle, eigenstateRegisterLE.Data, MicrosoftQuantumArithmeticLittleEndianAsBigEndian.Apply(frequencyEstimateNumerator)));
#line 272 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                                frequencyEstimate = MicrosoftQuantumArithmeticMeasureInteger.Apply(frequencyEstimateNumerator);
                            }
#line hidden
                            catch
                            {
                                __arg3__ = false;
                                throw;
                            }
#line hidden
                            finally
                            {
                                if (__arg3__)
                                {
#line hidden
                                    Release.Apply(register);
                                }
                            }
                        }
                    }

#line 278 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                    ResetAll.Apply(eigenstateRegister);
                }
#line hidden
                catch
                {
                    __arg1__ = false;
                    throw;
                }
#line hidden
                finally
                {
                    if (__arg1__)
                    {
#line hidden
                        Release.Apply(eigenstateRegister);
                    }
                }
            }

#line 281 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            return frequencyEstimate;
        }

        ;
        public override void Init()
        {
            this.Allocate = this.Factory.Get<Allocate>(typeof(Microsoft.Quantum.Intrinsic.Allocate));
            this.Release = this.Factory.Get<Release>(typeof(Microsoft.Quantum.Intrinsic.Release));
            this.MicrosoftQuantumArithmeticLittleEndian = this.Factory.Get<ICallable<IQArray<Qubit>, Microsoft.Quantum.Arithmetic.LittleEndian>>(typeof(Microsoft.Quantum.Arithmetic.LittleEndian));
            this.MicrosoftQuantumArithmeticApplyXorInPlace = this.Factory.Get<IUnitary<(Int64,Microsoft.Quantum.Arithmetic.LittleEndian)>>(typeof(Microsoft.Quantum.Arithmetic.ApplyXorInPlace));
            this.MicrosoftQuantumOraclesDiscreteOracle = this.Factory.Get<ICallable<IUnitary, Microsoft.Quantum.Oracles.DiscreteOracle>>(typeof(Microsoft.Quantum.Oracles.DiscreteOracle));
            this.ApplyOrderFindingOracle = this.Factory.Get<IUnitary<(Int64,Int64,Int64,IQArray<Qubit>)>>(typeof(ApplyOrderFindingOracle));
            this.MicrosoftQuantumCharacterizationRobustPhaseEstimation = this.Factory.Get<ICallable<(Int64,Microsoft.Quantum.Oracles.DiscreteOracle,IQArray<Qubit>), Double>>(typeof(Microsoft.Quantum.Characterization.RobustPhaseEstimation));
            this.MicrosoftQuantumMathRound = this.Factory.Get<ICallable<Double, Int64>>(typeof(Microsoft.Quantum.Math.Round));
            this.MicrosoftQuantumConvertIntAsDouble = this.Factory.Get<ICallable<Int64, Double>>(typeof(Microsoft.Quantum.Convert.IntAsDouble));
            this.MicrosoftQuantumMathPI = this.Factory.Get<ICallable<QVoid, Double>>(typeof(Microsoft.Quantum.Math.PI));
            this.MicrosoftQuantumCharacterizationQuantumPhaseEstimation = this.Factory.Get<IUnitary<(Microsoft.Quantum.Oracles.DiscreteOracle,IQArray<Qubit>,Microsoft.Quantum.Arithmetic.BigEndian)>>(typeof(Microsoft.Quantum.Characterization.QuantumPhaseEstimation));
            this.MicrosoftQuantumArithmeticLittleEndianAsBigEndian = this.Factory.Get<ICallable<Microsoft.Quantum.Arithmetic.LittleEndian, Microsoft.Quantum.Arithmetic.BigEndian>>(typeof(Microsoft.Quantum.Arithmetic.LittleEndianAsBigEndian));
            this.MicrosoftQuantumArithmeticMeasureInteger = this.Factory.Get<ICallable<Microsoft.Quantum.Arithmetic.LittleEndian, Int64>>(typeof(Microsoft.Quantum.Arithmetic.MeasureInteger));
            this.ResetAll = this.Factory.Get<ICallable<IQArray<Qubit>, QVoid>>(typeof(Microsoft.Quantum.Intrinsic.ResetAll));
        }

        public override IApplyData __dataIn((Int64,Int64,Boolean,Int64) data) => new In(data);
        public override IApplyData __dataOut(Int64 data) => new QTuple<Int64>(data);
        public static System.Threading.Tasks.Task<Int64> Run(IOperationFactory __m__, Int64 generator, Int64 modulus, Boolean useRobustPhaseEstimation, Int64 bitsize)
        {
            return __m__.Run<EstimateFrequency, (Int64,Int64,Boolean,Int64), Int64>((generator, modulus, useRobustPhaseEstimation, bitsize));
        }
    }

    [SourceLocation("/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs", OperationFunctor.Body, 306, 349)]
    public partial class PeriodFromFrequency : Function<(Int64,Int64,Int64,Int64), Int64>, ICallable
    {
        public PeriodFromFrequency(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(Int64,Int64,Int64,Int64)>, IApplyData
        {
            public In((Int64,Int64,Int64,Int64) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits => null;
        }

        String ICallable.Name => "PeriodFromFrequency";
        String ICallable.FullName => "Quantum.Bell.PeriodFromFrequency";
        protected ICallable<(Microsoft.Quantum.Math.Fraction,Int64), Microsoft.Quantum.Math.Fraction> MicrosoftQuantumMathContinuedFractionConvergentI
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64), Microsoft.Quantum.Math.Fraction> MicrosoftQuantumMathFraction
        {
            get;
            set;
        }

        protected ICallable<Int64, Int64> MicrosoftQuantumMathAbsI
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64), Int64> MicrosoftQuantumMathGreatestCommonDivisorI
        {
            get;
            set;
        }

        public override Func<(Int64,Int64,Int64,Int64), Int64> Body => (__in__) =>
        {
            var (modulus,frequencyEstimate,bitsPrecision,currentDivisor) = __in__;
#line 316 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            var (numerator,period) = MicrosoftQuantumMathContinuedFractionConvergentI.Apply((new Microsoft.Quantum.Math.Fraction((frequencyEstimate, 2L.Pow(bitsPrecision))), modulus)).Data;
#line 321 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            var (numeratorAbs,periodAbs) = (MicrosoftQuantumMathAbsI.Apply(numerator), MicrosoftQuantumMathAbsI.Apply(period));
#line 325 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            return ((periodAbs * currentDivisor) / MicrosoftQuantumMathGreatestCommonDivisorI.Apply((currentDivisor, periodAbs)));
        }

        ;
        public override void Init()
        {
            this.MicrosoftQuantumMathContinuedFractionConvergentI = this.Factory.Get<ICallable<(Microsoft.Quantum.Math.Fraction,Int64), Microsoft.Quantum.Math.Fraction>>(typeof(Microsoft.Quantum.Math.ContinuedFractionConvergentI));
            this.MicrosoftQuantumMathFraction = this.Factory.Get<ICallable<(Int64,Int64), Microsoft.Quantum.Math.Fraction>>(typeof(Microsoft.Quantum.Math.Fraction));
            this.MicrosoftQuantumMathAbsI = this.Factory.Get<ICallable<Int64, Int64>>(typeof(Microsoft.Quantum.Math.AbsI));
            this.MicrosoftQuantumMathGreatestCommonDivisorI = this.Factory.Get<ICallable<(Int64,Int64), Int64>>(typeof(Microsoft.Quantum.Math.GreatestCommonDivisorI));
        }

        public override IApplyData __dataIn((Int64,Int64,Int64,Int64) data) => new In(data);
        public override IApplyData __dataOut(Int64 data) => new QTuple<Int64>(data);
        public static System.Threading.Tasks.Task<Int64> Run(IOperationFactory __m__, Int64 modulus, Int64 frequencyEstimate, Int64 bitsPrecision, Int64 currentDivisor)
        {
            return __m__.Run<PeriodFromFrequency, (Int64,Int64,Int64,Int64), Int64>((modulus, frequencyEstimate, bitsPrecision, currentDivisor));
        }
    }

    [SourceLocation("/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs", OperationFunctor.Body, 349, -1)]
    public partial class MaybeFactorsFromPeriod : Function<(Int64,Int64,Int64), (Boolean,(Int64,Int64))>, ICallable
    {
        public MaybeFactorsFromPeriod(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(Int64,Int64,Int64)>, IApplyData
        {
            public In((Int64,Int64,Int64) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits => null;
        }

        public class Out : QTuple<(Boolean,(Int64,Int64))>, IApplyData
        {
            public Out((Boolean,(Int64,Int64)) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits => null;
        }

        String ICallable.Name => "MaybeFactorsFromPeriod";
        String ICallable.FullName => "Quantum.Bell.MaybeFactorsFromPeriod";
        protected ICallable<(Int64,Int64,Int64), Int64> MicrosoftQuantumMathExpModI
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64), Int64> MicrosoftQuantumMathMaxI
        {
            get;
            set;
        }

        protected ICallable<(Int64,Int64), Int64> MicrosoftQuantumMathGreatestCommonDivisorI
        {
            get;
            set;
        }

        protected ICallable<String, QVoid> Message
        {
            get;
            set;
        }

        public override Func<(Int64,Int64,Int64), (Boolean,(Int64,Int64))> Body => (__in__) =>
        {
            var (modulus,generator,period) = __in__;
#line 352 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
            if (((period % 2L) == 0L))
            {
#line 356 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                var halfPower = MicrosoftQuantumMathExpModI.Apply((generator, (period / 2L), modulus));
#line 360 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                if ((halfPower != (modulus - 1L)))
                {
#line 365 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                    var factor = MicrosoftQuantumMathMaxI.Apply((MicrosoftQuantumMathGreatestCommonDivisorI.Apply(((halfPower - 1L), modulus)), MicrosoftQuantumMathGreatestCommonDivisorI.Apply(((halfPower + 1L), modulus))));
#line 371 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                    return (true, (factor, (modulus / factor)));
                }
                else
                {
#line 374 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                    return (false, (1L, 1L));
                }
            }
            else
            {
#line 379 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                Message.Apply("Estimated period was odd, trying again.");
#line 380 "/Users/Matt/Documents/Masters/Dissertation/Quantum/Testing/Inital_Test/Operations.qs"
                return (false, (1L, 1L));
            }
        }

        ;
        public override void Init()
        {
            this.MicrosoftQuantumMathExpModI = this.Factory.Get<ICallable<(Int64,Int64,Int64), Int64>>(typeof(Microsoft.Quantum.Math.ExpModI));
            this.MicrosoftQuantumMathMaxI = this.Factory.Get<ICallable<(Int64,Int64), Int64>>(typeof(Microsoft.Quantum.Math.MaxI));
            this.MicrosoftQuantumMathGreatestCommonDivisorI = this.Factory.Get<ICallable<(Int64,Int64), Int64>>(typeof(Microsoft.Quantum.Math.GreatestCommonDivisorI));
            this.Message = this.Factory.Get<ICallable<String, QVoid>>(typeof(Microsoft.Quantum.Intrinsic.Message));
        }

        public override IApplyData __dataIn((Int64,Int64,Int64) data) => new In(data);
        public override IApplyData __dataOut((Boolean,(Int64,Int64)) data) => new Out(data);
        public static System.Threading.Tasks.Task<(Boolean,(Int64,Int64))> Run(IOperationFactory __m__, Int64 modulus, Int64 generator, Int64 period)
        {
            return __m__.Run<MaybeFactorsFromPeriod, (Int64,Int64,Int64), (Boolean,(Int64,Int64))>((modulus, generator, period));
        }
    }
}